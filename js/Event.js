/**
 * Created by linxiaojie on 2015/10/14.
 */

var slice = [].slice,
    separator = /\s+/,

    returnFalse = function() {
        return false;
    },

    returnTrue = function() {
        return true;
    };

function eachEvent(events, callback, iterator) {

    // 不支持对象，只支持多个event用空格隔开
    (events || '').split(separator).forEach(function(type) {
        iterator(type, callback);
    });
};

// 生成匹配namespace正则
function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
};

// 分离event name和event namespace
function parse(name) {
    var parts = ('' + name).split('.');

    return {
        e: parts[0],
        ns: parts.slice(1).sort().join(' ')
    };
};

function findHandlers(arr, name, callback, context) {
    var matcher,
        obj;

    obj = parse(name);
    obj.ns && (matcher = matcherFor(obj.ns));
    return arr.filter(function(handler) {
        return handler &&
            (!obj.e || handler.e === obj.e) &&
            (!obj.ns || matcher.test(handler.ns)) &&
            (!callback || handler.cb === callback ||
            handler.cb._cb === callback) &&
            (!context || handler.ctx === context);
    });
};
/**
 * Event类，结合gmu.event一起使用, 可以使任何对象具有事件行为。包含基本`preventDefault()`, `stopPropagation()`方法。
 * 考虑到此事件没有Dom冒泡概念，所以没有`stopImmediatePropagation()`方法。而`stopProgapation()`的作用就是
 * 让之后的handler都不执行。
 *
 * @class Event
 * @constructor
 * ```javascript
 * var obj = {};
 *
 * $.extend( obj, gmu.event );
 *
 * var etv = gmu.Event( 'beforeshow' );
 * obj.trigger( etv );
 *
 * if ( etv.isDefaultPrevented() ) {
			 *     console.log( 'before show has been prevented!' );
			 * }
 * ```
 * @grammar new gmu.Event( name[, props]) => instance
 * @param {String} type 事件名字
 * @param {Object} [props] 属性对象，将被复制进event对象。
 */

function Event(type, props) {
    if (!(this instanceof Event)) {
        return new Event(type, props);
    }

    props && $.extend(this, props);
    this.type = type;

    return this;
}

Event.prototype = {

    /**
     * @method isDefaultPrevented
     * @grammar e.isDefaultPrevented() => Boolean
     * @desc 判断此事件是否被阻止
     */
    isDefaultPrevented: returnFalse,

    /**
     * @method isPropagationStopped
     * @grammar e.isPropagationStopped() => Boolean
     * @desc 判断此事件是否被停止蔓延
     */
    isPropagationStopped: returnFalse,

    /**
     * @method preventDefault
     * @grammar e.preventDefault() => undefined
     * @desc 阻止事件默认行为
     */
    preventDefault: function() {
        this.isDefaultPrevented = returnTrue;
    },

    /**
     * @method stopPropagation
     * @grammar e.stopPropagation() => undefined
     * @desc 阻止事件蔓延
     */
    stopPropagation: function() {
        this.isPropagationStopped = returnTrue;
    }
};

module.exports =  {

    /**
     * 绑定事件。
     * @method on
     * @grammar on( name, fn[, context] ) => me
     * @param  {String}   name     事件名
     * @param  {Function} callback 事件处理器
     * @param  {Object}   context  事件处理器的上下文。
     * @return {me} 返回自身，方便链式
     * @chainable
     */
    on: function(name, callback, context) {
        var me = this,
            set;

        if (!callback) {
            return this;
        }

        set = this._events || (this._events = []);

        eachEvent(name, callback, function(name, callback) {
            var handler = parse(name);

            handler.cb = callback;
            handler.ctx = context;
            handler.ctx2 = context || me;
            handler.id = set.length;
            set.push(handler);
        });

        return this;
    },

    /**
     * 绑定事件，且当handler执行完后，自动解除绑定。
     * @method one
     * @grammar one( name, fn[, context] ) => me
     * @param  {String}   name     事件名
     * @param  {Function} callback 事件处理器
     * @param  {Object}   context  事件处理器的上下文。
     * @return {me} 返回自身，方便链式
     * @chainable
     */
    one: function(name, callback, context) {
        var me = this;

        if (!callback) {
            return this;
        }

        eachEvent(name, callback, function(name, callback) {
            var once = function() {
                me.off(name, once);
                return callback.apply(context || me, arguments);
            };

            once._cb = callback;
            me.on(name, once, context);
        });

        return this;
    },

    /**
     * 解除事件绑定
     * @method off
     * @grammar off( name[, fn[, context] ] ) => me
     * @param  {String}   name     事件名
     * @param  {Function} callback 事件处理器
     * @param  {Object}   context  事件处理器的上下文。
     * @return {me} 返回自身，方便链式
     * @chainable
     */
    off: function(name, callback, context) {
        var events = this._events;

        if (!events) {
            return this;
        }

        if (!name && !callback && !context) {
            this._events = [];
            return this;
        }

        eachEvent(name, callback, function(name, callback) {
            findHandlers(events, name, callback, context)
                .forEach(function(handler) {
                    delete events[handler.id];
                });
        });

        return this;
    },

    /**
     * 触发事件
     * @method trigger
     * @grammar trigger( name[, ...] ) => me
     * @param  {String | Event }   evt     事件名或gmu.Event对象实例
     * @param  {*} * 任意参数
     * @return {me} 返回自身，方便链式
     * @chainable
     */
    trigger: function(evt) {
        var i = -1,
            args,
            events,
            stoped,
            len,
            ev;

        if (!this._events || !evt) {
            return this;
        }

        typeof evt === 'string' && (evt = new Event(evt));

        args = slice.call(arguments, 1);
        evt.args = args; // handler中可以直接通过e.args获取trigger数据
        args.unshift(evt);

        events = findHandlers(this._events, evt.type);

        if (events) {
            len = events.length;

            while (++i < len) {
                if ((stoped = evt.isPropagationStopped()) || false ===
                    (ev = events[i]).cb.apply(ev.ctx2, args)
                ) {

                    // 如果return false则相当于stopPropagation()和preventDefault();
                    stoped || (evt.stopPropagation(), evt.preventDefault());
                    break;
                }
            }
        }

        return this;
    }
};
